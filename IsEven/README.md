# Алгоритм четности целого
__Задача:__
На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.

```py
def isEven(value):
    return value % 2 == 0
```
__Решение:__
Минусы данной реализации в том, что value может быть форматированной строкой, например `"hello %s"`, а такие строки используют перегрузку оператора взятия остатка от деления. В таком случае возвращаемое значение станет `"hello 2" == 0`, то есть `False`. Функция молча отработает создав неопределенное поведение вместо исключения.

Решить данную проблему можно проверив тип входных данных. Сделать это можно разными способами, и тут многое зависит от контекста программы. Одним из самых быстрых способов будет вызвать у переменной атрибут имеющийся только у экземпляра целого числа. Например bit_count.
```py
def isEven(value):
    try:
        value.bit_count() # это быстрее чем value.bit_count или isinstance
        return value & 1 == 0
        # проверяем младший бит на четность
    except AttributeError:
        raise TypeError("Unsupported type. Expecting integer value.")
```
Таким образом пользователь узнает, что произошло. Однако гипотетически может так случится, что параметр value имеет атрибут bit_count, но не является целым числом.

Реализация с применением cython использует строгую типизацию и является уже скомпилированой функцией, поэтому будет обгонять аналогичную реализацию из описания к задаче.

---

Чтобы запустить компиляцию и тесты выполните:
```
python run.py
```
