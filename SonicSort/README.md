# Сортировка с минимальным процессорным временем

__Задание:__
На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить почему вы считаете, что функция соответствует заданным критериям.


__Решение:__
Самым быстрым способом отсортировать массив чисел - будет воспользоваться фунцией sort из библиотеки numpy.

```py
import numpy

array = numpy.array(somelist, numpy.int64)
array.sort()
```
Используемый по умолчанию алгоритм функции sort хорошо оптимизирован и использует комбинации mergesort, quicksort/introsort, timsort в зависимости от того какую производительность в процессе сортировки показывает алгоритм.

Массиву можно задать ограничение по типу значений, что может ускорить сортировку в десятки, если не в сотни раз.

Но задание, как я понял - реализовать функцию. Поэтому для реализации я выбирал между radixsort и quicksort. 

__Radixsort__ занимает в среднем $O(nk)$ операций, где k может быть очень большим, например `sys.maxsize`. В этом случае он теряет свою эффективность.

__Quicksort__ занимает в среднем $O(n \log n)$ операций, что более предсказуемо для чисел любого размера. Худший случай $O(n^2)$ на практике редко встречается со случайными числами. Хотя и с ним можно работать, если есть понимание какие данные сортируются.

Для наглядности я реализовал __quicksort__ на cython, чтобы сравнить его производительность с timsort - родным алгоритмом сортировки в python. Алгоритм использует структуры данных языка C, что позволяет отключить GIL и сборщик мусора, и таким образом сократить процессорное время. На моей машине в среднем он немного быстрей :)

Для того, чтобы использовать функцию, ее сначала нужно скомпилировать. Для этого нужно запустить build.py в директории SonicSort/. После компиляции должен появится файл quicksort.so
> Без этого файла тесты не будут работать!

Тесты находятся в файле SonicSort/tests.py
```
python3 -m unittest tests
```
Код для сравнения производительности в файле bench.py.

---

Чтобы запустить копиляцию и тесты выполните:
```
python run.py
```